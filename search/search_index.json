{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome &amp; getting started","text":"<p>sec21 is a collection of useful functions and classes and the boilerplate for a lot of my projects.</p>"},{"location":"#build-and-install-using-cmake","title":"Build and install using CMake","text":"<p>Building with CMake on Linux is very easy, just use the following shell commands: <pre><code>git clone https://github.com/MichaelMiller-/sec21\ncd sec21\nmkdir _build &amp;&amp; cd _build/\ncmake ..\nsudo make install\n</code></pre></p>"},{"location":"#usage-in-cmake-projects","title":"Usage in CMake projects","text":"<p>If you have installed sec21 system-wide you can use the CMake-package-system. <pre><code>find_package(sec21 CONFIG REQUIRED)\n## ...\ntarget_link_libraries(main PRIVATE sec21::sec21)\n</code></pre></p>"},{"location":"#using-fetchcontent","title":"Using FetchContent","text":"<p>Alternatively, the project can also be used only in a private context. Simply add the following to your CMakeLists.txt: <pre><code>## If BUILD_TESTING for sec21 is enabled make sure that Catch2 is available.\n## find_package(Catch2 CONFIG REQUIRED)\n\ninclude(FetchContent)\nFetchContent_Declare(sec21\n        GIT_REPOSITORY https://github.com/MichaelMiller-/sec21\n        GIT_TAG ... # Commit hash\n        )\nFetchContent_MakeAvailable(sec21)\nset_target_properties(sec21 PROPERTIES BUILD_TESTING FALSE)\n\n## Link against sec21::sec21\ntarget_link_libraries(main PRIVATE sec21::sec21)\n</code></pre></p>"},{"location":"csv-writer/","title":"CSV writer","text":"<p>#include &lt;sec21/write_csv.h&gt;</p> <p>Another algorithm that makes use of the reflection library is a CSV writer. Here, the table format is used and written to a stream in a formatted way.</p>"},{"location":"csv-writer/#example","title":"Example","text":"<pre><code>struct user\n{\n   std::string name{};\n   std::string password{};\n   int karma{};\n   double cash{}; \n};\n\ntemplate &lt;&gt;\nstruct sec21::reflection::table&lt;user&gt;\n{\n   static constexpr auto name = \"user\";\n\n   struct columns\n   {\n      using name = column&lt;\"name\", &amp;user::name&gt;;\n      using password = column&lt;\"password\", &amp;user::password&gt;;\n      using karma = column&lt;\"karma\", &amp;user::karma&gt;;\n      using cash = column&lt;\"cash\", &amp;user::cash&gt;;\n   };\n\n   using metainfo = std::tuple&lt;\n      columns::name,\n      columns::password,\n      columns::karma,\n      columns::cash&gt;;\n};\n\n// \nstd::vector&lt;user&gt; input{\n   { \"John Doe\", \"secret\", 42, 0 },\n   { \"Max Mustermann\", \"****\", 1, 45'678 }\n};\nsec21::write_csv(std::cout, input);\n</code></pre> <p>The output is: <pre><code>name, password, karma, cash\nJohn Doe, secret, 42, 0\nMax Mustermann, ****, 1, 45678\n</code></pre></p>"},{"location":"reflection/","title":"sec21::reflection","text":"<p>The idea behind this library is not to change existing data structures, but to achieve reflection functionality via a simple template specialization. </p> <p>Note:  Based on this development, another library has been created that makes use of the Reflection TS. Feel free to check it out. Link</p>"},{"location":"reflection/#example","title":"Example","text":"<pre><code>// example class / existing code\nstruct user\n{\n   std::string name{};\n   std::string password{};\n   int karma{};\n   double cash{}; \n};\n\nstruct rectangle\n{\n    double width{};\n    double height{};\n};\n</code></pre> <p>The existing classes can be made known to the system via template specialization.</p> <pre><code>// specialize 'sec21::reflection::table' template for those classes\n//\ntemplate &lt;&gt;\nstruct sec21::reflection::table&lt;user&gt;\n{\n   static constexpr auto name = \"user\";\n\n   struct columns\n   {\n      using name = column&lt;\"name\", &amp;user::name, primary_key, not_null&gt;;\n      using password = column&lt;\"password\", &amp;user::password, not_null&gt;;\n      using karma = column&lt;\"karma\", &amp;user::karma&gt;;\n      using cash = column&lt;\"cash\", &amp;user::cash&gt;;\n   };\n\n   using metainfo = std::tuple&lt;\n      columns::name,\n      columns::password,\n      columns::karma,\n      columns::cash&gt;;\n};\n\n// \ntemplate &lt;&gt;\nstruct sec21::reflection::table&lt;rectangle&gt;\n{\n   static constexpr auto name = \"rectangle\";\n\n   struct columns\n   {\n      using width = column&lt;\"width\", &amp;rectangle::width&gt;;\n      using height = column&lt;\"height\", &amp;rectangle::height&gt;;\n   };\n\n   using metainfo = std::tuple&lt;columns::width, columns::height&gt;;\n};\n</code></pre> <p>Once the classes have been made known to the reflection system, it is very easy to develop generic algorithms that take advantage of the system.</p> <pre><code>// generic algorithm that works with any type that provides a reflection specialization\ntemplate &lt;typename T&gt;\nvoid print_first_column(std::vector&lt;T&gt; const&amp; values)\n{\n    using namespace sec21;\n    using reflection_t = typename reflection::table&lt;T&gt;::metainfo;\n    for (auto const&amp; value : values)\n    {\n        std::cout &lt;&lt; reflection::get_column&lt;0&gt;(value) &lt;&lt; std::endl;\n    }    \n}\n\nint main()\n{\n    {\n        std::vector&lt;user&gt; input{\n            { \"John Doe\", \"secret\", 42, 0 },\n            { \"Max Mustermann\", \"****\", 1, 45'678 }\n        };\n        print_first_column(input);\n    }\n    {\n        std::vector&lt;rectangle&gt; input{\n            { 3.14, 4.15 },\n            { 1.41, 2.77 }\n        };\n        print_first_column(input);\n    }\n   return 0;\n</code></pre> <p>The output is: <pre><code>John Doe\nMax Mustermann\n3.14\n1.41\n</code></pre></p>"},{"location":"sql-database-support/","title":"SQL database","text":"<p>With the help of the reflection library, it is very easy to map data structures as SQL tables.</p> <pre><code>struct user\n{\n   std::string name{};\n   std::string password{};\n   int karma{};\n   double cash{}; \n};\n\ntemplate &lt;&gt;\nstruct sec21::reflection::table&lt;user&gt;\n{\n   static constexpr auto name = \"user\";\n\n   struct columns\n   {\n      using name = column&lt;\"name\", &amp;user::name, database::primary_key, database::not_null&gt;;\n      using password = column&lt;\"password\", &amp;user::password, database::not_null&gt;;\n      using karma = column&lt;\"karma\", &amp;user::karma&gt;;\n      using cash = column&lt;\"cash\", &amp;user::cash&gt;;\n   };\n\n   using metainfo = std::tuple&lt;\n      columns::name,\n      columns::password,\n      columns::karma,\n      columns::cash&gt;;\n};\n</code></pre> <p>As you can see the original data structure is not changed. Instead, the table is specified by the template specialization of the <code>reflection::table</code> class. In addition, the first two columns are given freely selectable keywords as constraints. This is followed by a data type mapping for the corresponding database dialect. In this case, PostgreSQL data types are mapped.</p> <pre><code>namespace sec21::database\n{\n   template &lt;&gt;\n   struct column_type&lt;int&gt;\n   {\n      static constexpr std::string_view value = \"INT\";\n   };\n   template &lt;&gt;\n   struct column_type&lt;std::string&gt;\n   {\n      static constexpr std::string_view value = \"TEXT\";\n   };\n   template &lt;&gt;\n   struct column_type&lt;double&gt;\n   {\n      static constexpr std::string_view value = \"REAL\";\n   };\n} // namespace sec21::database\n</code></pre> <p>In the database library there are various functions to generate SQL statements.</p> <pre><code>{\n  auto sql_statement = sec21::database::create_table&lt;user&gt;();\n\n  // sql_statement = \"CREATE TABLE user(name TEXT PRIMARY KEY NOT NULL,password TEXT NOT NULL,karma INT,cash REAL);\"\n}\n{\n  user obj{.name = \"John Doe\", .password = \"hidden\", .karma = 42, .cash = 3.14};\n  auto sql_statement = sec21::database::insert_into(obj);\n\n  // sql_statement == \"INSERT INTO user (name,password,karma,cash) VALUES ('John Doe','hidden',42,3.14);\"\n}\n</code></pre>"},{"location":"type-traits/","title":"sec21::type_traits","text":"<p>Templates for fundamental properties of types.</p> Name Description contains Template which checks whether an explicit type is in a type list index_of Calculates the index of a type in a type list instance_of Checks whether a type corresponds to an instantiation of a class is_specialized Checks if a specialisation of a template class is available is_std_string Checks whether the type is a std::string is_tuple Checks whether the type is a std::tuple member_pointer_traits Decomposes a pointer to a member into it's components"},{"location":"units/","title":"Units","text":"<p>Is a modern, lightweight library for dimensional analysis.  Inspired by Boost-Units and Boost-MPL.  In order to be able to use their full range of functions, only one include is required.  <pre><code>#include &lt;sec21/units.h&gt;\n</code></pre></p> <p>The library is also very easy to expand. If a dimension is missing, it can be created very easily and made known to the system. The following is an example of pressure, the dimension of which is equal to M L^-1 T^-2.  <pre><code>using pressure = dimension&lt;\n   exponent&lt;base_dimension_mass, 1&gt;, \n   exponent&lt;base_dimension_length, -1&gt;,\n   exponent&lt;base_dimension_time, -2&gt;&gt;;\n</code></pre> The basic dimensions represent freely chosen compiletime constants.  The procedure is similarly simple for new units. These just have to be defined and derived from derived_unit.</p> <pre><code>struct pascal : derived_unit&lt;pascal, pressure, base_unit&gt; {};\nstruct kilopascal : derived_unit&lt;kilopascal, pressure, std::kilo&gt; {};\n// ...\n</code></pre>"},{"location":"units/#dependencies","title":"Dependencies","text":"<ul> <li>Boost.Mp11</li> <li>nlohmann/json</li> </ul>"},{"location":"api/all_of-any_of/","title":"all_of / any_of","text":"<p>#include &lt;sec21/all_of.h&gt; #include &lt;sec21/any_of.h&gt;</p> <p>Zero overhead syntax helper which also works with lambdas.</p>"},{"location":"api/all_of-any_of/#example","title":"Example","text":"<pre><code>int x{10};\nint y{50};\nint z{99};\n\nif (all_of{x, y, z} &lt; 100) {\n   // do something\n}\n\nauto lambda1 = [](auto e){ return e &lt; 100; };\nauto lambda2 = [](auto e){ return e &gt; 5; };\nauto lambda3 = [](auto e){ return e &gt; 10; };\n\nauto func = all_of{lambda1, lambda2, lambda3};\n\nif (func(16)) {\n   // do something\n}\n</code></pre> <p>Those classes could also be used in a compile-time context.</p>"},{"location":"api/all_of-any_of/#example_1","title":"Example","text":"<pre><code>static_assert(all_of{10, 50, 99} &lt; 100); \n</code></pre>"},{"location":"api/arity/","title":"arity","text":"<p>#include &lt;sec21/arity.h&gt;</p> <p>Count the number of arguments of any given callable, including generic lambdas and generic function objects.</p>"},{"location":"api/arity/#example","title":"Example","text":"<pre><code>// plan function\nvoid func(int, int);\nstatic_assert(arity(func) == 2);\n\n// function object\nstruct binary_functor {\n   template &lt;typename T, typename U&gt;\n   void operator()(T, U) {}\n};\nstatic_assert(arity(binary_functor{}) == 2);\n\n// generic lambda\nconst auto l3 = [](auto, auto, auto) {};\nstatic_assert(arity(l3) == 3);\n</code></pre>"},{"location":"api/array_qvm_vec_traits/","title":"array_qvm_vec_traits","text":"<p>#include &lt;sec21/array_qvm_vec_traits.h&gt;</p> <p>In this header is a vec_traits specialization that allows Boost QVM functions to operate directly on arrays of type std::array.</p>"},{"location":"api/bit_pattern/","title":"bit_pattern","text":"<p>#include &lt;sec21/bit_pattern.h&gt;</p> <p>Matches the bits via a pattern. The letter x represents a placeholder.</p>"},{"location":"api/bit_pattern/#example","title":"Example","text":"<pre><code>static_assert(0b1101010u == bit_pattern(\"11xxx10\"));\n</code></pre>"},{"location":"api/blob/","title":"blob","text":"<p>#include &lt;sec21/blob.h&gt;</p> <p>This class represents any type as a memory blob.   </p>"},{"location":"api/blob/#example","title":"Example","text":"<pre><code>struct foo\n{\n   int x{0};\n   int y{0};\n   double d{};\n   float f{};\n   std::array&lt;int, 8&gt; a{};\n};\n\nfoo obj{17, 42, 3.14, 4.2f, {1, 2, 4, 5, 6, 7, 8, 9}};\n// store object in a blob\nauto mem = blob{obj};\n// restore object of type 'foo' from the memory blob\nfoo result = mem;\n// or simply retrieve the first integer\nint i = mem;  // i == 17\n\n// It is also possible to convert the memory blob into a std::string\nstd::string str = to_string(mem);\n// and read from a std::string\nblob mem1{blob::parse, str};\n</code></pre>"},{"location":"api/concat/","title":"concat","text":"<p>#include &lt;sec21/concat.h&gt;</p> <p>Joins string-convertible objects into one string. There are overloads for std::tuple and variadic template parameters. It is also possible to specify the delimiter between the objects.</p> <pre><code>auto input = std::make_tuple(\"foo\", \"bar\", \"baz\");\nauto result = concat(input, \"+++\");  // == \"foo+++bar+++baz\");\n</code></pre>"},{"location":"api/contains/","title":"contains","text":"<p>#include &lt;sec21/type_traits/contains.h&gt;</p> <p>Template which checks whether an explicit type is in a type list. </p>"},{"location":"api/contains/#example","title":"Example","text":"<pre><code>using type_list_t = std::tuple&lt;int, float, double&gt;;\n\nstatic_assert(contains&lt;int, type_list_t&gt;::value == true);\nstatic_assert(contains&lt;float, type_list_t&gt;::value == true);\nstatic_assert(contains&lt;double, type_list_t&gt;::value == true);\nstatic_assert(contains&lt;char, type_list_t&gt;::value == false);\n</code></pre>"},{"location":"api/eventsystem/","title":"Eventsystem","text":"<p>The input_manager represents an abstraction layer to system events that are triggered by the hardware (keyboard, mouse, ...). This abstraction allows input events to be simulated using simple input data (JSON files). Making the eventsystem and other systems built on it such as a commmand-queue filled by hardware events very easy to test.</p> <p>It allows various custom backends. The only limitation is that the backend defines a method poll_event(). This must return a <code>std::tuple&lt;bool, event_t&gt;</code> and can take a variable number of parameters. These parameters are passed from the <code>input_manager</code> to the backend.</p> <p><pre><code>struct possible_backend\n{\n   std::tuple&lt;bool, event_t&gt; poll_event();\n};\n</code></pre> The backend should also be able to convert the events provided by the eventsystem into the appropriate backend format. Two sample backends are already implemented:  - SDL2 - SFML</p>"},{"location":"api/eventsystem/#dependencies","title":"Dependencies","text":"<ul> <li>nlohmann/json</li> </ul>"},{"location":"api/expects/","title":"expects","text":"<p>#include &lt;sec21/expects.h&gt;</p> <p>A simple one-liner that provides general error handling. If the condition evaluates to false, a centrally defined action is executed with the passed text.</p> <pre><code>// if the condition is false a std::runtime_error is thrown\nexpects([=]{ return value &gt; 23; }, \"value has to be greater than 23\");\n</code></pre>"},{"location":"api/fixed_string/","title":"fixed_string","text":"<p>#include &lt;sec21/fixed_string.h&gt;</p> <p>Compile-time string. Pretty useful as template parameter. </p> <p>Possible will be replaced by the C++ standard P3094R6</p>"},{"location":"api/fixed_string/#example","title":"Example","text":"<pre><code>template &lt;fixed_string Name, typename T&gt;\nstruct anything { };\n\nusing foo_t = anything&lt;\"foo\", int&gt;;\n</code></pre>"},{"location":"api/for_each_adjacent/","title":"for_each_adjacent","text":"<p>#include &lt;sec21/for_each_adjacent.h&gt;</p> <p>Apply a function for two consecutive elements in a sequence.</p> <pre><code>auto input = std::vector{ 1, 2, 3, 4, 5, 6, 7, 8 };\nfor_each_adjacent(input, [](auto x, auto y){ std::cout &lt;&lt; \"x: \" &lt;&lt; x &lt;&lt; \" y: \" &lt;&lt; y &lt;&lt; std::endl; });\n\n// output:\n// x: 1 y: 2  \n// x: 2 y: 3  \n// x: 3 y: 4\n// x: 4 y: 5\n// x: 5 y: 6\n// x: 6 y: 7\n// x: 7 y: 8\n</code></pre>"},{"location":"api/for_each_chunk/","title":"for_each_chunk","text":"<p>#include &lt;sec21/for_each_chunk.h&gt;</p> <p>Apply a function to every chunk in a range.</p> <pre><code>auto input = std::vector{ 1, 2, 3, 4, 5, 6, 7, 8 };\nfor_each_chunk&lt;2&gt;(input, [](auto x, auto y){ std::cout &lt;&lt; \"x: \" &lt;&lt; x &lt;&lt; \" y: \" &lt;&lt; y &lt;&lt; std::endl; });\n\n// output:\n// x: 1 y: 2  \n// x: 3 y: 4  \n// x: 5 y: 6  \n// x: 7 y: 8  \n</code></pre>"},{"location":"api/for_each_indexed/","title":"for_each_indexed","text":"<p>#include &lt;sec21/for_each_indexed.h&gt;</p> <p>Executes the passed function per element with the associated index. There is another overload where the start index can be specified.</p> <pre><code>auto input = std::vector{ 4, 3, 2, 1 };\nfor_each_indexed(\n   begin(input), \n   end(input), \n   [](auto index, auto value) { std::cout &lt;&lt; \"i: \" &lt;&lt; index &lt;&lt; \" v: \" &lt;&lt; value &lt;&lt; std::endl; });\n\n// output:\n// i: 0 v: 4  \n// i: 1 v: 3  \n// i: 2 v: 2  \n// i: 3 v: 1  \n</code></pre>"},{"location":"api/for_each_indexed/#alternatives","title":"Alternatives","text":"<p>The C++ standard also offers alternatives.</p>"},{"location":"api/for_each_indexed/#stl-with-a-mutable-lambda","title":"STL with a mutable lambda","text":"<pre><code>auto input = std::vector{ 4, 3, 2, 1 };\nstd::for_each(\n   begin(input), \n   end(input), \n   [index = 0](auto value) mutable { std::cout &lt;&lt; \"i: \" &lt;&lt; index++ &lt;&lt; \" v: \" &lt;&lt; value &lt;&lt; std::endl; });\n</code></pre>"},{"location":"api/for_each_indexed/#c20-ranges","title":"C++20 ranges","text":"<pre><code>auto input = std::vector{ 4, 3, 2, 1 };\nfor (auto const [index, value] : std::views::enumerate(input))\n{\n   std::cout &lt;&lt; \"i: \" &lt;&lt; index &lt;&lt; \" v: \" &lt;&lt; value &lt;&lt; std::endl;\n}\n</code></pre>"},{"location":"api/index_of/","title":"index_of","text":"<p>#include &lt;sec21/type_traits/index_of.h&gt;</p> <p>Calculates the index of a type in a type list.</p>"},{"location":"api/index_of/#example","title":"Example","text":"<pre><code>static_assert(index_of&lt;int, int, float, char&gt;::value == 0);\nstatic_assert(index_of&lt;float, int, float, char&gt;::value == 1);\nstatic_assert(index_of&lt;char, int, float, char&gt;::value == 2);\nstatic_assert(index_of&lt;double, int, float, char&gt;::value == -1);   // -1 == not found\n</code></pre>"},{"location":"api/instance_of/","title":"instance_of","text":"<p>#include &lt;sec21/type_traits/instance_of.h&amp;gt</p> <p>Checks whether a type corresponds to an instantiation of a class.</p>"},{"location":"api/instance_of/#example","title":"Example","text":"<pre><code>static_assert(is_instance_of_v&lt;std::basic_string, std::string&gt; == true);\nstatic_assert(is_instance_of_v&lt;std::tuple, std::tuple&lt;int, double&gt;&gt; == true);\nstatic_assert(is_instance_of_v&lt;std::tuple, std::vector&lt;int&gt;&gt; == false);\nstatic_assert(is_instance_of_v&lt;std::vector, std::tuple&lt;int, double&gt;&gt; == false);\n</code></pre>"},{"location":"api/is_specialized/","title":"is_specialized","text":"<p>#include &lt;sec21/type_traits/is_specialized.h&gt;</p> <p>Checks if a specialisation of a template class is available.</p>"},{"location":"api/is_specialized/#example","title":"Example","text":"<pre><code>namespace ns\n{\n   template &lt;typename T&gt;\n   struct foo;\n\n   template &lt;&gt;\n   struct foo&lt;int&gt; {};\n\n   template &lt;&gt;\n   struct foo&lt;std::string&gt; {};\n}\n\nstatic_assert(is_specialized_v&lt;ns::foo, int&gt;);\nstatic_assert(is_specialized_v&lt;ns::foo, double&gt; == false);\nstatic_assert(is_specialized_v&lt;ns::foo, float&gt; == false);\nstatic_assert(is_specialized_v&lt;ns::foo, std::string&gt; == true);\nstatic_assert(is_specialized_v&lt;ns::foo, std::wstring&gt; == false);\n</code></pre>"},{"location":"api/is_std_string/","title":"is_std_string","text":"<p>#include &lt;sec21/type_traits/is_std_string.h&gt;</p> <p>Checks whether the type is a std::string.</p>"},{"location":"api/is_std_string/#example","title":"Example","text":"<pre><code>static_assert(is_std_string&lt;std::string&gt;::value == true);\nstatic_assert(is_std_string&lt;int&gt;::value == false);\nstatic_assert(is_std_string&lt;std::wstring&gt;::value == false);\nstatic_assert(is_std_string&lt;float&gt;::value == false);\n</code></pre>"},{"location":"api/is_tuple/","title":"is_tuple","text":"<p>#include &lt;sec21/type_traits/is_tuple.h&gt;</p> <p>Checks whether the type is a std::tuple."},{"location":"api/is_tuple/#example","title":"Example","text":"<pre><code>static_assert(is_tuple_v&lt;std::tuple&lt;int, float, int&gt;&gt; == true);\nstatic_assert(is_tuple_v&lt;std::tuple&lt;&gt;&gt; == true);\nstatic_assert(is_tuple_v&lt;int&gt; == false);\nstatic_assert(is_tuple_v&lt;std::string&gt; == false);\nstatic_assert(is_tuple_v&lt;double&gt; == false);\n</code></pre>"},{"location":"api/json_serializer/","title":"json_serializer","text":"<p>#include &lt;sec21/json_serializer_array.h&gt; #include &lt;sec21/json_serializer_optional.h&gt; #include &lt;sec21/json_serializer_uuid.h&gt; #include &lt;sec21/json_serializer_variant.h&gt; </p> <p>Several template specialization for nlohmann/json. </p>"},{"location":"api/limited_quantity/","title":"limited_quantity","text":"<p>#include &lt;sec21/limited_quantity.h&gt;</p> <p>Represents a value between two fixed endpoints [Infimum, Supremum]. </p> <pre><code>using value_t = sec21::limited_quantity&lt;int, 1, 10&gt;;\n\n{\n   value_t value{10};\n   ++value; // throws a exception\n}\n{\n   value_t value{1};\n   --value; // throws a exception\n}\n</code></pre>"},{"location":"api/member_pointer_traits/","title":"member_pointer_traits","text":"<p>#include &lt;sec21/type_traits/member_pointer_traits.h&gt;</p> <p>Decomposes a pointer to a member into it's components.</p>"},{"location":"api/member_pointer_traits/#example","title":"Example","text":"<pre><code>class cls {};\n\nstatic_assert(std::is_same_v&lt;member_pointer_traits&lt;int(cls::*)&gt;::class_t, cls&gt;);\nstatic_assert(std::is_same_v&lt;member_pointer_traits&lt;int(cls::*)&gt;::value_t, int&gt;);\n</code></pre>"},{"location":"api/memory/","title":"memory","text":"<p>#include &lt;sec21/memory.h&gt;</p> <p>A small helper class to deal with memory units. Including arithmetic operations, string literals and specialization for std::format.</p>"},{"location":"api/memory/#example","title":"Example","text":"<pre><code>#include &lt;sec21/literals/memory.h&gt;\nusing namespace sec21::literals;\n\n// arithmetic operations\nauto value1 = 4_kiB + std::byte{4}; // memory{4100}\n\n// :h shows the value in a human-readable format\nauto value2 = std::format(\"{:h}\", memory{1_kiB}); // \"1.02kB\"\nauto value3 = std::format(\"{:.0h}\", memory{1024 * 1024}); // == \"1MB\"\n</code></pre>"},{"location":"api/overloaded/","title":"overloaded","text":"<p>#include &lt;sec21/overloaded.h&gt;</p> <p>Famous std::visit helper: https://en.cppreference.com/w/cpp/utility/variant/visit.</p>"},{"location":"api/scope_guard/","title":"scope_guard","text":"<p>#include &lt;sec21/scope_guard.h&gt;</p> <p>General-purpose scope guard intended to call its exit function when a scope is exited. </p> <p>This will possible be replaced with https://en.cppreference.com/w/cpp/experimental/lib_extensions_3.  </p>"},{"location":"api/split_if/","title":"split_if","text":"<p>#include &lt;sec21/split_if.h&gt;</p> <p>Divides the elements in a range, defined by [first, last], into two destination ranges depending on a predicate. If the predicate is true then the current element is appended to the first destination range, otherwise to the second.</p>"},{"location":"api/split_if/#example","title":"Example","text":"<pre><code>std::vector in{1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\nstd::vector&lt;int&gt; result1{};\nstd::vector&lt;int&gt; result2{};\n\nsplit_if(begin(in), end(in), back_inserter(result1), back_inserter(result2), [](auto i) { return i &lt; 5; });\n\n// result1  == { 1, 2, 3, 4 }; \n// result2  == { 5, 6, 7, 8, 9, 10 }; \n</code></pre>"},{"location":"api/strong_type/","title":"strong_type","text":"<p>#include &lt;sec21/strong_type.h&gt;</p> <p>The static typing of the programming language C ++ allows you to design types that exactly meet the specified requirements. Due to the policy-based design of 'strong_type' it is very easy to design new types. For example, a counter-like type should be designed which can only be incremented. Trying to decrement an object of this type will result in a compiler error.  <pre><code>using counter_t = strong_type&lt;int, struct counter_tag, policy::increment&gt;;\n\ncounter_t cnt{ 42 };\n++cnt;          // counter_t.value == 43\n// --cnt;       // is not possible\n</code></pre> Due to the specific type, interfaces can be developed much more safely and clearly. The following example illustrates this well. The interface uses POD data types as function arguments. When the function is called, the order of the arguments cannot be guaranteed and errors can occur during execution.  <pre><code>void set_window_dimension(int width, int height);\n// ...\nint input_width{ 800 };\nint input_height{ 800 };\n\n// interface call\nvoid set_window_dimension(input_width, input_height);\n// work's as well\nvoid set_window_dimension(input_height, input_width);\n</code></pre> A strong_type function argument, however, forces the caller side to explicitly specify the type. Among other things, this also improves the readability of the code.  <pre><code>using width_t = strong_type&lt;int, struct width_tag&gt;;\nusing height_t = strong_type&lt;int, struct height_tag&gt;;\n\nvoid set_window_dimension(width_t{ 800 }, height_t{ 600 });\n</code></pre> Furthermore, the behavior and the interface of the strong_type can be extended and tested very easily. The following example shows a type that represents an alphabet. Incrementing above the last letter can throw an error or provide a new value with an index. </p> <pre><code>template &lt;typename T&gt;\n// A(0) ... Z(0) ... A1 ... Z1 ... A2 ... Z2 ... \nstruct increment_alphabet\n{\n   T&amp; operator ++ () noexcept\n   {\n      using type_t = typename T::underlying_t;\n      static_assert(std::is_same_v&lt;type_t, std::string&gt;);\n\n      // get reference to the underlaying type\n      auto&amp; result = static_cast&lt;type_t&amp;&gt;(static_cast&lt;T&amp;&gt;(*this));\n\n      // modify value\n      if (result[0] == 'Z') {\n         const auto tmp = type_t{ next(begin(result)), end(result) };\n         unsigned long long number{0};\n         std::from_chars(tmp.data(), tmp.data() + tmp.size(), number);\n         result = fmt::format(\"A{}\", ++number);\n      }\n      else\n         ++result[0];\n\n      return static_cast&lt;T&amp;&gt;(*this);\n   }\n};\n\nusing alhpabet_t = strong_type&lt;\n   std::string, \n   struct alhpabet_tag, \n   increment_alphabet, \n   policy::compare&gt;;\n\nalhpabet_t obj{ \"Z\" };\n++obj;\nREQUIRE(obj == \"A1\");\n</code></pre>"},{"location":"api/to_array/","title":"to_array","text":"<p>#include &lt;sec21/to_array.h&gt;</p> <p>Transforms any given std::tuple into a std::array.  <pre><code>auto input = std::make_tuple(1, 2, 3, 4.44f, 5.55, \"string\");\nauto result = to_array(input, [](auto v) {\n  std::stringstream ss;\n  ss &lt;&lt; \"v: \" &lt;&lt; v;\n  return ss.str();\n});\n\n// result is std::array&lt;std::string, 6&gt;{  \"v: 1\", \"v: 2\", \"v: 3\", \"v: 4.44\", \"v: 5.55\", \"v: string\" }; \n</code></pre>"},{"location":"api/transform/","title":"transform","text":"<p>#include &lt;sec21/transform.h&gt;</p> <p>Transforms any given std::tuple. <pre><code>auto input = std::make_tuple(1, 2, 3, 4.44);\nauto result = transform(input, [](auto v) { return v * 2; });\n\n// result is std::tuple&lt;int, int, int, double&gt;{ 2, 4, 6, 8.88 }; \n</code></pre>"},{"location":"api/transform_if/","title":"transform_if","text":"<p>#include &lt;sec21/transform_if.h&gt;</p> <p>Transforms any element in a range, defined by [first, last), into a destination range if the predicate is satisfied. </p>"},{"location":"api/transform_if/#example","title":"Example","text":"<pre><code>std::vector in{1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\nstd::vector&lt;Data&gt; result{};\n\ntransform_if(\n  std::begin(in),\n  std::end(in),\n  std::back_inserter(result),\n  [](auto i) { return i &lt; 5; },\n  [](auto i) { return Data{i}; });\n\n// result == { Data{1}, Data{2}, Data{3}, Data{4} }; \n</code></pre>"},{"location":"api/validate/","title":"validate","text":"<p>#include &lt;sec21/validate.h&gt;</p>"},{"location":"api/validate/#every-input-has-to-be-validated","title":"Every input has to be validated","text":"<p>Usually if it comes to input processing we tend to write something like that: <pre><code>std::string any_input_string{\"...\"};\n\nif (any_input_string == \"list_files\")\n{\n  call_list_files();\n}\nif (any_input_string.starts_with(\"input_file\"))\n{\n  auto parts = split(any_input_string, \"=\");\n  if (parts.size() == 2 &amp;&amp; parts[0] == \"input_file\" &amp;&amp; !parts[1].empty()) {\n    process_input_file(parts[1]);\n  }\n  throw std::invalid_argument(\"cannot parse 'input_file' argument\");\n}\n// ...\nelse {\n  throw std::invalid_argument(\"invalid input\");\n}\n</code></pre> This code is really tedious and very error prune and worst of all it is not very good testable. This is where sec21::validate comes in place.</p> <p>It's separate concerns via small pieces of code that are not tied together, that makes it by default easy extensible. This design also makes it very to test, like the following example will show. </p>"},{"location":"api/validate/#testable","title":"Testable","text":"<pre><code>// define a action\nstruct action1 {};\n\n// specialize the 'validate' template class\ntemplate &lt;&gt;\nstruct validate&lt;action1&gt;\n{\n   std::optional&lt;action1&gt; operator()(std::string_view input) const noexcept\n   {\n      if (input == \"action1\") {\n         return action1{};\n      }\n      return std::nullopt;\n   }\n};\n\n// write some test. in this case via Catch2\nTEST_CASE(\"validate action1\")\n{\n  SECTION(\"matches with input string\")\n  {\n    validate&lt;action1&gt; obj;\n    REQUIRE(obj(\"action1\").has_value());\n  }\n  SECTION(\"misspelling 1\")\n  {\n    validate&lt;action1&gt; obj;\n    REQUIRE(obj(\"action21\").has_value() == false);\n  }\n  SECTION(\"misspelling 2\")\n  {\n    validate&lt;action1&gt; obj;\n    REQUIRE(obj(\"action11\").has_value() == false);\n  }\n}\n</code></pre>"},{"location":"api/validate/#example","title":"Example","text":"<pre><code>// user actions\nstruct list_files {};\nstruct input_file { std::filesystem::path filename{}; };\n\n// specialize the 'validate' template class\ntemplate &lt;&gt;\nstruct sec21::validate&lt;list_files&gt;\n{\n  std::optional&lt;list_files&gt; operator()(std::string_view input) const noexcept\n  {\n    if (input == \"list_files\") {\n      return list_files{};\n    }\n    return std::nullopt;\n  }\n};\n\ntemplate &lt;&gt;\nstruct sec21::validate&lt;input_file&gt;\n{\n  std::optional&lt;input_file&gt; operator()(std::string_view input) const\n  {\n    std::vector&lt;std::string&gt; parts{};\n    boost::split(parts, input, [](auto c) { return c == '='; });\n\n    if (size(parts) == 2 &amp;&amp; parts[0] == \"input_file\" &amp;&amp; std::filesystem::exists(parts[1])) {\n      return input_file{ parts[1] };\n    }\n    return std::nullopt;\n  }\n};\n\n// validate any input. could be commandline-arguments, file-content, console, ...\nauto result = input_dispatcher&lt;list_files, input_file&gt;{}(any_string);\n\n// note: 'overloaded' class is found here: https://en.cppreference.com/w/cpp/utility/variant/visit\nstd::visit(overloaded{\n        [](list_files){ std::cout &lt;&lt; \"list files action\" &lt;&lt; std::endl; },\n        [](input_file const&amp; obj){ std::cout &lt;&lt; \"input file= \" &lt;&lt; obj.filename &lt;&lt; std::endl; },\n        [](invalid_input){ std::cout &lt;&lt; \"invalid input\" &lt;&lt; std::endl; }\n    }, result);\n</code></pre> <p>Be aware that std::variant is a type-safe union and the that any missing overload results into a compile time error. Therefore it is very hard to get things wrong.</p>"},{"location":"api/zip/","title":"zip","text":"<p>#include &lt;sec21/zip.h&gt;</p> <p>Iterate over several containers at the same time and call a function with the respective contents per iteration step.</p>"},{"location":"api/zip/#example","title":"Example","text":"<p><pre><code>std::vector keys{ 1, 2, 3 };\nstd::vector&lt;std::string&gt; values{ \"foo\", \"bar\", \"baz\" };\nstd::map&lt;int, std::string&gt; result;\n\nzip(\n   [&amp;result](auto key, auto value) { result[key] = value; },\n   begin(keys),\n   end(keys),\n   begin(values));\n\n// result = { { 1, \"foo\" }, { 2, \"bar\" }, { 3, \"baz\" } }\n</code></pre> Or reorder the content from a container and store it in a new one.</p>"},{"location":"api/zip/#example_1","title":"Example","text":"<pre><code>std::vector in{1,3,5,7,2,4,6,8};\nstd::vector&lt;int&gt; result{};\n\nauto it1 = begin(in);\nauto it2 = next(begin(in), 4);\n\nzip([&amp;result](auto v1, auto v2){\n    result.push_back(v1);\n    result.push_back(v2);\n}, it1, it2, it2);\n\n// result == { 1, 2, 3, 4, 5, 7, 8 };\n</code></pre>"}]}